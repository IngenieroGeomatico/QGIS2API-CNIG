# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QGIS2APICNIGDialog
                                 A QGIS plugin
 Complemento que crea un visualizador cartográfico con el contenido del lienzo de QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-12-16
        git sha              : $Format:%H$
        copyright            : (C) 2023 by IngenieroGeomatico
        email                : aurearagon@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from pathlib import Path
import shutil
import webbrowser

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.core import (
                        QgsProject, QgsMapLayer, QgsWkbTypes, QgsCoordinateTransform, 
                        QgsCoordinateReferenceSystem, QgsVectorFileWriter, QgsCoordinateTransformContext,
                        QgsMessageLog
                       )
from qgis.gui import QgsMapCanvas
from qgis.utils import iface, Qgis

from PyQt5 import QtGui, QtWidgets



# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'QGIS2APICNIG_dialog_base.ui'))


class QGIS2APICNIGDialog(QtWidgets.QDialog, FORM_CLASS):
    
    def __init__(self, parent=None):
        """Constructor."""
        super(QGIS2APICNIGDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

    def selectFolder(self):
        dialog = QtWidgets.QFileDialog()
        if self.lineEdit_Folder.text().replace(" ","").replace("—","_") == '':
            folder_path = dialog.getExistingDirectory(None, "Selecciona carpeta de salida")
        else:
            folder_path = dialog.getExistingDirectory(self.lineEdit_Folder, "Selecciona carpeta de salida")  

        if folder_path == None or folder_path == "":
            folder_path = self.lineEdit_Folder.text()

        self.lineEdit_Folder.setText(folder_path)
        return folder_path

    def exportMap(self):
        projectSource = "/QGIS2APICNIG"
        sourceFolder = "/Sources"
        exportFolder = self.lineEdit_Folder.text() + projectSource
        exportFolderSources = self.lineEdit_Folder.text() + projectSource + sourceFolder

        if Path(exportFolder).exists() == True:
            shutil.rmtree(exportFolder)
        Path(exportFolder).mkdir(parents=True, exist_ok=True)
        Path(exportFolderSources).mkdir(parents=True, exist_ok=True)
        fileMap=exportFolder + '/index.html'

        tableOfSources = self.tableWidget_capas
        # print("tableOfSources.columnCount(): ", tableOfSources.columnCount())
        # print("tableOfSources.rowCount(): ", tableOfSources.rowCount())

        layers = []
        controls = []
        plugins = []

        # Contenido de la tabla:
        # [ 0-> capa superpuesta, 1-> visible, 2-> tipo de capa, 3-> fuente de la capa, 4-> nombre]
        initialZIndexLayer = 100
        initialZIndexLayerMax = initialZIndexLayer + tableOfSources.rowCount()
        for r in range(tableOfSources.rowCount()):
            layer={
                'layerSourceType':'',
                'url_path':'',
                'format':'',
                'style':'',
                'nameLayer':'',
                'nameLegend':'',
                'visible':0,
                'isLocal':0,
                'dataSourceUri':'',
                'source':'',
                'QGISlayer':'',
                'sourceFolder':sourceFolder,
                'exportFolderSources':exportFolderSources,
                'zIndex': initialZIndexLayer - r
            }
            
            
            for c in range(tableOfSources.columnCount()):
                item = tableOfSources.item(r, c)
                if item == None:
                    cell_widget = tableOfSources.cellWidget(r, c)
                    if cell_widget is not None:
                        chk_box = cell_widget.findChild(QtWidgets.QCheckBox).isChecked()
                        # c = 0 --> capa supuerpuesta
                        if c == 0:
                            # print('check capa superpuesta:  ',chk_box)
                            if chk_box == False:
                                break
                        # c = 1 --> capa visible
                        elif c == 1:
                            # print('check visible:  ',chk_box)
                            layer['visible'] = chk_box
                            continue
                
                else:
                    text = str(item.text())

                    # c = 2 --> tipo de capa
                    if c == 2:
                        # print('tipo de la capa: ',text)
                        pass
                    
                    # c = 3 --> fuente de la capa
                    elif c == 3:
                        # print('fuente de la capa: ',text)
                        layer['layerSourceType'] = text
                    
                    # c = 4 --> nombre
                    elif c == 4:
                        QGISlayer = QgsProject.instance().mapLayersByName(text)[0]
                        layer['QGISlayer'] = QGISlayer
                        # print('nombre de la capa: ',QGISlayer.name())
                        layer['nameLegend'] = QGISlayer.name()
                        layer['dataSourceUri'] = QGISlayer.dataProvider().dataSourceUri()
                        layer['source'] = QGISlayer.source()

                        if layer['dataSourceUri'] == '':
                            layer['dataSourceUri'] = layer['source'] 
                    
                if c == tableOfSources.columnCount() -1 :
                    layers.append( self.JSONLayer2StringLayer(layer) )      
        
        layers = list(filter( lambda k: '' != k, layers ))        
        layers = list(reversed(layers))    

        # Obtención de controles y plugins
        # ["scale","scaleline","panzoombar","panzoom","location","getfeatureinfo","rotate","backgroundlayers"]
        checkBox_checkBox_SelectorCapas = self.checkBox_SelectorCapas.isChecked()
        checkBox_CapasBase = self.checkBox_CapasBase.isChecked()
        checkBox_Rotacion = self.checkBox_Rotacion.isChecked()
        checkBox_Localizacion = self.checkBox_Localizacion.isChecked()
        checkBox_EscalaZoom = self.checkBox_EscalaZoom.isChecked()
        checkBox_ZoomBotones = self.checkBox_ZoomBotones.isChecked()
        checkBox_ZoomBarrita = self.checkBox_ZoomBarrita.isChecked()
        checkBox_EscalaGrafica = self.checkBox_EscalaGrafica.isChecked()


        # Comprobación controles
        print('checkBox_CapasBase', checkBox_CapasBase)
        if checkBox_CapasBase:
            controls.append('backgroundlayers')
        if checkBox_Rotacion:
            controls.append('rotate')
        if checkBox_Localizacion:
            controls.append('location')
        if checkBox_EscalaZoom:
            controls.append('scale')
        if checkBox_ZoomBotones:
            controls.append('panzoom')
        if checkBox_ZoomBarrita:
            controls.append('panzoombar')
        if checkBox_EscalaGrafica:
            controls.append('scaleline')

        # Comprobación plugins
        if checkBox_checkBox_SelectorCapas:
            stringplugin = """
                            var css_selectorCapa = document.createElement("link");
                            css_selectorCapa.rel = "stylesheet";
                            css_selectorCapa.href = "https://componentes.cnig.es/api-core/plugins/toc/toc.ol.min.css";
                            document.head.appendChild(css_selectorCapa);


                            var js_selectorCapa = document.createElement("script");
                            js_selectorCapa.type = "text/javascript";
                            js_selectorCapa.async = false;
                            js_selectorCapa.src = "https://componentes.cnig.es/api-core/plugins/toc/toc.ol.min.js";
                            document.head.appendChild(js_selectorCapa);

                            
                            js_selectorCapa.addEventListener('load', () => {{

                                const mp_selectorCapa = new M.plugin.TOC({
                                        postition: 'TL',
                                        collapsed: false,
                                        collapsible: true,
                                        tooltip: 'Selector de capa superpuesta'
                                    });

                                mapajs.addPlugin(mp_selectorCapa);

                            }})
                            
                           """
            plugins.append(stringplugin)

        
        extentQGIS = iface.mapCanvas().extent()
        CRSQGIS = QgsProject.instance().crs()
        ct = QgsCoordinateTransform(CRSQGIS, QgsCoordinateReferenceSystem('EPSG:3857'), QgsProject.instance())
        bounds_crs = ct.transformBoundingBox(extentQGIS)
        bbox = [ bounds_crs.xMinimum() , bounds_crs.yMinimum() , bounds_crs.xMaximum() , bounds_crs.yMaximum() ]
        
        with open(fileMap, 'w') as filetowrite:
            filetowrite.write( self.CreateHTML(bbox, layers, controls, plugins) )

        webbrowser.open(fileMap,new=2)
        self.close ()
        return

    def JSONLayer2StringLayer(self, layer):

        def removeSpaces(txt):
            return '"'.join(it if i % 2 else ''.join(it.split())
                            for i, it in enumerate(txt.split('"')))
        
        def toLocalGeoJSON(layer, layerGJSON, APICNIGStyle):
            stringLayer="""
                                var js_{name} = document.createElement("script");
                                js_{name}.type = "text/javascript";
                                js_{name}.async = false;
                                js_{name}.src = ".{sourceFolder}/{file}";
                                document.head.appendChild(js_{name});
                                js_{name}.addEventListener('load', () => {{
                                
                                    mapajs.addLayers(
                                        new M.layer.GeoJSON({{
                                                source: {source}, 
                                                name: '{layerGJSON}',
                                                legend: "{name}",
                                                extract: true,
                                            }}, {{
                                            // aplica un estilo a la capa
                                                style: {APICNIGStyle},
                                                visibility: {visible} // capa no visible en el mapa
                                            }}, {{
                                                opacity: 1 // aplica opacidad a la capa
                                            }})
                                    );

                                    mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})

                                }});
                                """.format(
                                    sourceFolder = layer['sourceFolder'],
                                    file = layer['nameLegend'].replace(" ","").replace("—","_")+'.js',
                                    source = layer['nameLegend'].replace(" ","").replace("—","_"),
                                    name = layer['nameLegend'].replace(" ","").replace("—","_"),
                                    visible = str(layer['visible']).lower(),
                                    layerGJSON=layerGJSON,
                                    APICNIGStyle=APICNIGStyle,
                                    zindex = layer['zIndex'],
                                )
            return stringLayer
        
        stringLayer = ''

        if layer['layerSourceType'] == 'XYZ':
            urlURI = list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split('&') ))[0]

            if urlURI:
                url = urlURI.split('=')[1]
                url = url.replace('%7B','{')
                url = url.replace('%7D','}')

            stringLayer="""
                                mapajs.addXYZ(
                                    new M.layer.XYZ({{
                                        url: '{url}',
                                        name: '{name}',
                                        visibility: {visible},
                                        legend: '{name}',
                                    }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    zindex = layer['zIndex'],

                                )

        elif layer['layerSourceType'] == 'TMS':
            urlURI = list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split('&') ))[0]

            if urlURI:
                url = urlURI.split('=')[1]
                url = url.replace('%7B','{')
                url = url.replace('%7D','}')

            stringLayer="""
                                mapajs.addTMS(
                                    new M.layer.TMS({{
                                        url: '{url}',
                                        name: '{name}',
                                        visibility: {visible},
                                        legend: '{name}',
                                    }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    zindex = layer['zIndex'],

                                )

        elif layer['layerSourceType'] == 'WMTS':
            urlURI = list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split('&') ))[0]
            formatURI = list(filter( lambda k: 'format=' in k, layer['dataSourceUri'].split('&') ))[0]
            layerURI = list(filter( lambda k: 'layers=' in k, layer['dataSourceUri'].split('&') ))[0]
            stylesURI = list(filter( lambda k: 'styles=' in k, layer['dataSourceUri'].split('&') ))[0]

            if urlURI:
                url = urlURI.split('=')[1]
            if formatURI:
                formatWMTS = formatURI.split('=')[1]
            if layerURI:
                layerWMTS = layerURI.split('=')[1]
            if stylesURI:
                styleWMTS = stylesURI.split('=')[1]

            stringLayer="""
                                mapajs.addWMTS(
                                    new M.layer.WMTS({{
                                        url: '{url}',
                                        name: "{layerWMTS}",
                                        legend: "{name}",
                                        visibility: {visible},
                                        }},
                                        {{
                                            format: '{formatWMTS}'
                                        }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    formatWMTS=formatWMTS,
                                    layerWMTS=layerWMTS,
                                    zindex = layer['zIndex'],
                                )

        elif layer['layerSourceType'] == 'WMS':
            urlURI = list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split('&') ))[0]
            formatURI = list(filter( lambda k: 'format=' in k, layer['dataSourceUri'].split('&') ))[0]
            layerURI = list(filter( lambda k: 'layers=' in k, layer['dataSourceUri'].split('&') ))[0]
            if 'styles=' in layer['dataSourceUri']:
                stylesURI = list(filter( lambda k: 'styles=' in k, layer['dataSourceUri'].split('&') ))[0]
            else:
                stylesURI = None

            if urlURI:
                url = urlURI.split('=')[1]
            if formatURI:
                formatWMS = formatURI.split('=')[1]
            if layerURI:
                layerWMS = layerURI.split('=')[1]
            if stylesURI:
                styleWMS = stylesURI.split('=')[1]

            stringLayer="""
                                mapajs.addWMS(
                                     new M.layer.WMS({{
                                            url: '{url}',
                                            name: "{layerWMS}",
                                            legend: "{name}",
                                            tiled: false,
                                            visibility: {visible},
                                        }}, 
                                        {{
                                            format: '{formatWMS}'
                                        }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    formatWMS=formatWMS,
                                    layerWMS=layerWMS,
                                    zindex = layer['zIndex'],
                                )
        
        elif layer['layerSourceType'] == 'OGC WFS (Web Feature Service)':

            urlURI = list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split(' ') ))[0]
            layerURI = list(filter( lambda k: 'typename=' in k, layer['dataSourceUri'].split(' ') ))[0]

            if urlURI:
                url = urlURI.split('=')[1]
            if layerURI:
                layerWFS = layerURI.split('=')[1]

            APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])

            stringLayer="""
                                mapajs.addWFS(
                                     new M.layer.WFS({{
                                            url: {url}, 
                                            name: {layerWFS},
                                            legend: "{name}",
                                            extract: true,
                                        }}, {{
                                        // aplica un estilo a la capa
                                            style: {APICNIGStyle},
                                            visibility: {visible} // capa no visible en el mapa
                                        }}, {{
                                            opacity: 1 // aplica opacidad a la capa
                                        }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    layerWFS=layerWFS,
                                    APICNIGStyle=APICNIGStyle,
                                    zindex = layer['zIndex'],
                                )
        
        elif layer['layerSourceType'] == 'GeoJSON':

            if 'http' in layer['dataSourceUri']:
                urlURI = layer['dataSourceUri'].split('|')[0]
                layerURI = list(filter( lambda k: 'layername=' in k, layer['dataSourceUri'].split('|') ))[0]

                if urlURI:
                    url = urlURI.replace('/vsicurl/','')
                if layerURI:
                    layerGJSON = layerURI.split('=')[1]
                
                APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])

                stringLayer="""
                                mapajs.addLayers(
                                     new M.layer.GeoJSON({{
                                            url: '{url}', 
                                            name: '{layerGJSON}',
                                            legend: "{name}",
                                            extract: true,
                                        }}, {{
                                        // aplica un estilo a la capa
                                            style: {APICNIGStyle},
                                            visibility: {visible} // capa no visible en el mapa
                                        }}, {{
                                            opacity: 1 // aplica opacidad a la capa
                                        }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    layerGJSON=layerGJSON,
                                    APICNIGStyle=APICNIGStyle,
                                    zindex = layer['zIndex'],
                                )
            
            else:
                # Guardar la capa vectorial como geojson en local y hacerle el trapis para que pueda leerlo en local como objeto JS
                pathh = layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js'   
                options = []
                options.append("COORDINATE_PRECISION=" + str(6))
                e, err = QgsVectorFileWriter.writeAsVectorFormat(layer['QGISlayer'], 
                                                                 pathh + '_tmp',
                                                                 "utf-8", 
                                                                 QgsCoordinateReferenceSystem("EPSG:4326"), 
                                                                 'GeoJson',
                                                                 0, 
                                                                 layerOptions=options)
                if e == QgsVectorFileWriter.NoError:
                    with open(pathh, mode="w", encoding="utf8") as f:
                        f.write("var %s = " % (layer['nameLegend'].replace(" ","").replace("—","_")))
                        with open(pathh+ '_tmp', encoding="utf8") as tmpFile:
                            for line in tmpFile:
                                line = line.strip("\n\t ")
                                line = removeSpaces(line)
                                f.write(line)

                    os.remove(pathh + '_tmp')
                else:
                    QgsMessageLog.logMessage(
                        "Could not write json file {}: {}".format(layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js', err),
                        "qgis2APICNIG",
                        level=Qgis.Critical)
                    return
                
                layerURI = list(filter( lambda k: 'layername=' in k, layer['dataSourceUri'].split('|') ))[0]
                if layerURI:
                    layerGJSON = layerURI.split('=')[1]
                else:
                    layerGJSON=layer['nameLegend'].replace(" ","").replace("—","_")

                APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])

                stringLayer = toLocalGeoJSON(layer, layerGJSON, APICNIGStyle)
                            
        elif layer['layerSourceType'] == 'Memory storage':
            # Guardar la capa vectorial como geojson en local y hacerle el trapis para que pueda leerlo en local como objeto JS
                pathh = layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js'
                options = []
                options.append("COORDINATE_PRECISION=" + str(6))
                e, err = QgsVectorFileWriter.writeAsVectorFormat(layer['QGISlayer'], 
                                                                 pathh + '_tmp',
                                                                 "utf-8", 
                                                                 QgsCoordinateReferenceSystem("EPSG:4326"), 
                                                                 'GeoJson',
                                                                 0, 
                                                                 layerOptions=options)
                if e == QgsVectorFileWriter.NoError:
                    with open(pathh, mode="w", encoding="utf8") as f:
                        f.write("var %s = " % (layer['nameLegend'].replace(" ","").replace("—","_")))
                        with open(pathh+ '_tmp', encoding="utf8") as tmpFile:
                            for line in tmpFile:
                                line = line.strip("\n\t ")
                                line = removeSpaces(line)
                                f.write(line)

                    os.remove(pathh + '_tmp')
                else:
                    QgsMessageLog.logMessage(
                        "Could not write json file {}: {}".format(layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js', err),
                        "qgis2APICNIG",
                        level=Qgis.Critical)
                    return
                
                APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])
                layerGJSON=layer['nameLegend'].replace(" ","").replace("—","_")
                stringLayer = toLocalGeoJSON(layer, layerGJSON, APICNIGStyle)

        elif layer['layerSourceType'] == 'OGC API - Features':
            
            urlURI = list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split(' ') ))[0]
            layerURI = list(filter( lambda k: 'typename=' in k, layer['dataSourceUri'].split(' ') ))[0]

            if urlURI:
                url = urlURI.split('=')[1][:-1]+"collections/'"
            if layerURI:
                layerOGCAPI_Features = layerURI.split('=')[1]

            APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])

            stringLayer="""
                                mapajs.addOGCAPIFeatures(
                                     new M.layer.OGCAPIFeatures({{
                                            url: {url}, 
                                            name: {layerOGCAPI_Features},
                                            legend: "{name}",
                                            extract: true,
                                            limit: 100
                                        }}, {{
                                        // aplica un estilo a la capa
                                            style: {APICNIGStyle},
                                            visibility: {visible} // capa no visible en el mapa
                                        }}, {{
                                            opacity: 1 // aplica opacidad a la capa
                                        }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    layerOGCAPI_Features=layerOGCAPI_Features,
                                    APICNIGStyle=APICNIGStyle,
                                    zindex = layer['zIndex'],
            )

        elif layer['layerSourceType'] == 'LIBKML':

            if 'http' in layer['dataSourceUri']:

                if 'http' in layer['dataSourceUri']:
                    urlURI = layer['dataSourceUri'].split('|')[0]
                    layerURI = list(filter( lambda k: 'layername=' in k, layer['dataSourceUri'].split('|') ))[0]

                    if urlURI:
                        url = urlURI.replace('/vsicurl/','')
                    if layerURI:
                        layerGJSON = layerURI.split('=')[1]

                    stringLayer="""
                                    mapajs.addKML(
                                        new M.layer.KML({{
                                                url: '{url}', 
                                                name: "{name}",
                                                legend: "{name}",
                                                // layers: "{layerGJSON}",
                                                extract: true,
                                            }}, {{
                                                visibility: {visible} // capa no visible en el mapa
                                            }}, {{
                                                opacity: 1 // aplica opacidad a la capa
                                            }})
                                    );

                                    mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                    """.format(
                                        url = url,
                                        name = layer['nameLegend'],
                                        visible = str(layer['visible']).lower(),
                                        layerGJSON=layerGJSON,
                                        zindex = layer['zIndex'],
                                    )
            
            else:
                # Guardar la capa vectorial como geojson en local y hacerle el trapis para que pueda leerlo en local como objeto JS
                pathh = layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js'
                options = []
                options.append("COORDINATE_PRECISION=" + str(6))
                e, err = QgsVectorFileWriter.writeAsVectorFormat(layer['QGISlayer'], 
                                                                 pathh + '_tmp',
                                                                 "utf-8", 
                                                                 QgsCoordinateReferenceSystem("EPSG:4326"), 
                                                                 'GeoJson',
                                                                 0, 
                                                                 layerOptions=options)
                if e == QgsVectorFileWriter.NoError:
                    with open(pathh, mode="w", encoding="utf8") as f:
                        f.write("var %s = " % ( layer['nameLegend'].replace(" ","").replace("—","_") ))
                        with open(pathh+ '_tmp', encoding="utf8") as tmpFile:
                            for line in tmpFile:
                                line = line.strip("\n\t ")
                                line = removeSpaces(line)
                                f.write(line)

                    os.remove(pathh + '_tmp')
                else:
                    QgsMessageLog.logMessage(
                        "Could not write json file {}: {}".format(layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js', err),
                        "qgis2APICNIG",
                        level=Qgis.Critical)
                    return
                
                layerURI = list(filter( lambda k: 'layername=' in k, layer['dataSourceUri'].split('|') ))[0]
                if layerURI:
                    layerGJSON = layerURI.split('=')[1]
                else:
                    layerGJSON=layer['nameLegend'].replace(" ","").replace("—","_")

                APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])
               
                stringLayer = toLocalGeoJSON(layer, layerGJSON, APICNIGStyle)
                
        elif layer['layerSourceType'] == 'MVT':
            print(layer['dataSourceUri'])
            print(layer['dataSourceUri'].split('&') )
            print(list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split('&') ))[0])
            urlURI = list(filter( lambda k: 'url=' in k, layer['dataSourceUri'].split('&') ))[0]

            if urlURI:
                url = urlURI.split('=')[1]
                url = url.replace('%7B','{')
                url = url.replace('%7D','}')

            APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])

            stringLayer="""
                                mapajs.addLayers(
                                    new M.layer.MVT({{
                                        url: '{url}',
                                        name: '{name}',
                                        extract: true,
                                        visibility: {visible},
                                        legend: "{name}",
                                    }},{{
                                        // aplica un estilo a la capa
                                        style: {APICNIGStyle},
                                    }})
                                );

                                mapajs.getLayers().filter( (layer) => layer.legend == "{name}" )[0].setZIndex({zindex})
                                """.format(
                                    url = url,
                                    name = layer['nameLegend'],
                                    visible = str(layer['visible']).lower(),
                                    APICNIGStyle=APICNIGStyle,
                                    zindex = layer['zIndex'],
                                )

        elif layer['QGISlayer'].type() == QgsMapLayer.VectorLayer:
            # Guardar la capa vectorial como geojson en local y hacerle el trapis para que pueda leerlo en local como objeto JS
                pathh = layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js'
                options = []
                options.append("COORDINATE_PRECISION=" + str(6))
                e, err = QgsVectorFileWriter.writeAsVectorFormat(layer['QGISlayer'], 
                                                                 pathh + '_tmp',
                                                                 "utf-8", 
                                                                 QgsCoordinateReferenceSystem("EPSG:4326"), 
                                                                 'GeoJson',
                                                                 0, 
                                                                 layerOptions=options)
                if e == QgsVectorFileWriter.NoError:
                    with open(pathh, mode="w", encoding="utf8") as f:
                        f.write("var %s = " % ( layer['nameLegend'].replace(" ","").replace("—","_") ))
                        with open(pathh+ '_tmp', encoding="utf8") as tmpFile:
                            for line in tmpFile:
                                line = line.strip("\n\t ")
                                line = removeSpaces(line)
                                f.write(line)

                    os.remove(pathh + '_tmp')
                else:
                    QgsMessageLog.logMessage(
                        "Could not write json file {}: {}".format(layer['exportFolderSources']+'/'+layer['nameLegend'].replace(" ","").replace("—","_")+'.js', err),
                        "qgis2APICNIG",
                        level=Qgis.Critical)
                    return
                
                layerGJSON=layer['nameLegend'].replace(" ","").replace("—","_"),

                APICNIGStyle = self.QGISStyle2APICNIGStyle(layer['nameLegend'])

                stringLayer = toLocalGeoJSON(layer, layerGJSON, APICNIGStyle)

        return stringLayer

    def QGISStyle2APICNIGStyle(self, qgisLayerLegend):

        qgisLayer= QgsProject.instance().mapLayersByName(qgisLayerLegend)[0]

        typeStyle = qgisLayer.renderer().type()

        try:
            legendClassificationAttribute = qgisLayer.renderer().legendClassificationAttribute()
        except Exception as e:
            legendClassificationAttribute = "- - -"

        # Una capa puede tener más de une stilo, por lo que cuando en apicnig se permita un array de estilos, 
        # se podrá añadir cada estilo de qgis como un array desde un bucle.
        # De momento se coge el elemento 0
        
        try:
            propertiesStyle = qgisLayer.renderer().symbol().symbolLayer(0).properties()
        except Exception as e:
            propertiesStyle = "- - -"

        print('_____________________________')
        print('typeStyle  :',typeStyle)
        print('legendClassificationAttribute  :',legendClassificationAttribute)
        print('propertiesStyle :',propertiesStyle)
        print('_____________________________')


        if typeStyle == 'singleSymbol':
            
            if 'color' in propertiesStyle:
                fillColorRGBA_list= propertiesStyle['color'].split(',')
            else:
                fillColorRGBA_list= [255, 153, 0, 255/2]

            fillColorRGB = '''rgb({r}, {g}, {b})'''.format(
                r = int(fillColorRGBA_list[0]),
                g = int(fillColorRGBA_list[1]),
                b = int(fillColorRGBA_list[2]),
            )
            
            fillOpacity = int(fillColorRGBA_list[3]) / 255 

            if 'outline_color' in propertiesStyle:
                strokeColorRGBA_list= propertiesStyle['outline_color'].split(',')
            else:
                strokeColorRGBA_list= [255, 102, 0, 255]

            strokeColorRGB = '''rgb({r}, {g}, {b})'''.format(
                r = int(strokeColorRGBA_list[0]),
                g = int(strokeColorRGBA_list[1]),
                b = int(strokeColorRGBA_list[2]),
            )
            strokeOpacity = int(strokeColorRGBA_list[3]) / 255 

            if 'outline_color' in propertiesStyle:
                strokeWidth = float(propertiesStyle['outline_width'])
            else:
                strokeWidth = float(2)

            APICNIGStyle = '''new M.style.Generic({{
                                point: {{
                                    fill: {{
                                        color: '{fillColorRGB}',
                                        opacity: {fillOpacity},
                                    }},
                                    stroke: {{
                                        color: '{strokeColorRGB}',
                                        opacity: {strokeOpacity},
                                        width: {strokeWidth}, 
                                    }}
                                }},
                                polygon: {{
                                    fill: {{
                                        color: '{fillColorRGB}',
                                        opacity: {fillOpacity},
                                    }},
                                    stroke: {{
                                        color: '{strokeColorRGB}',
                                        opacity: {strokeOpacity},
                                        width: {strokeWidth}, 
                                    }}
                                }},
                                line: {{
                                    fill: {{
                                        color: '{fillColorRGB}',
                                        opacity: {fillOpacity},
                                    }},
                                    stroke: {{
                                        color: '{strokeColorRGB}',
                                        opacity: {strokeOpacity},
                                        width: {strokeWidth}, 
                                    }}
                                }}
                            }})'''.format(
                                    fillColorRGB = fillColorRGB,
                                    fillOpacity=fillOpacity,
                                    strokeColorRGB=strokeColorRGB,
                                    strokeOpacity=strokeOpacity,
                                    strokeWidth =strokeWidth,
                            )

        else:
            APICNIGStyle = '''new M.style.Generic({{
                                point: {{
                                    fill: {{
                                        color: '{fillColorRGB}',
                                        opacity: {fillOpacity},
                                    }},
                                    stroke: {{
                                        color: '{strokeColorRGB}',
                                        opacity: {strokeOpacity},
                                        width: {strokeWidth}, 
                                    }}
                                }},
                                polygon: {{
                                    fill: {{
                                        color: '{fillColorRGB}',
                                        opacity: {fillOpacity},
                                    }},
                                    stroke: {{
                                        color: '{strokeColorRGB}',
                                        opacity: {strokeOpacity},
                                        width: {strokeWidth}, 
                                    }}
                                }},
                                line: {{
                                    fill: {{
                                        color: '{fillColorRGB}',
                                        opacity: {fillOpacity},
                                    }},
                                    stroke: {{
                                        color: '{strokeColorRGB}',
                                        opacity: {strokeOpacity},
                                        width: {strokeWidth}, 
                                    }}
                                }}
                            }})'''.format(
                                    fillColorRGB = 'orange',
                                    fillOpacity=0.6,
                                    strokeColorRGB='red',
                                    strokeOpacity=0.8,
                                    strokeWidth = 2,
                            )
        
        return APICNIGStyle

    def CreateHTML(self, bbox, layers, controls, plugins):

        layersString = ''
        for l in layers:
            layersString = layersString + l

        pluginString = ''
        for l in plugins:
            pluginString = pluginString + l

        html = """<html>
                        <head>
                            <meta charset="UTF-8">
                            <title>Visualizador API-CNIG</title>
                            
                            <!-- Estilo de la API -->
                            <link type="text/css" rel="stylesheet" href="https://componentes.cnig.es/api-core/assets/css/apiign.ol.min.css">
                            
                            <style type="text/css">
                                html,
                                body {{
                                    margin: 0;
                                    padding: 0;
                                    height: 100%;
                                    overflow: hidden;
                                }}
                            </style>
                            
                            <!-- Ficheros javascript de la API -->
                            <script type="text/javascript" src="https://componentes.cnig.es/api-core/vendor/browser-polyfill.js"></script>
                            <script type="text/javascript" src="https://componentes.cnig.es/api-core/js/apiign.ol.min.js"></script>
                            <script type="text/javascript" src="https://componentes.cnig.es/api-core/js/configuration.js"></script>
                            
                        </head>
                        
                        <body>
                            <!-- Contenedor principal del mapa -->
                            <div id="mapaJS_div" class="m-container"></div>
                            
                            <script type="text/javascript">
                                
                                // Configuración del mapa
                                let zoomInicial = 5
                                let longLatInicial = [-3, 40]
                                const zoom_p = M.config.MAP_VIEWER_ZOOM || zoomInicial;
                                const center_p = M.config.MAP_VIEWER_CENTER || ol.proj.fromLonLat(longLatInicial);
                                
                                M.proxy(false) // Necesario para ejecutar el visualizador en local.
                                const mapajs = M.map({{
                                    container: 'mapaJS_div',
                                    controls: {controls},
                                    bbox: {bbox}
                                }});
                                
                                const layers_p = M.config.MAP_VIEWER_LAYERS || [];
                                mapajs.addLayers(layers_p)

                                {layers}

                                {plugins}
                                
                            </script>
                        </body>
                    </html>""".format(
                                    bbox = bbox,
                                    controls=controls,
                                    layers = layersString,
                                    plugins = pluginString,
                                )
        return html

